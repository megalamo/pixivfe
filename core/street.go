// Copyright 2023 - 2025, VnPower and the PixivFE contributors
// SPDX-License-Identifier: AGPL-3.0-only

package core

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"codeberg.org/pixivfe/pixivfe/v3/core/cookie"
	"codeberg.org/pixivfe/pixivfe/v3/core/requests"
	"codeberg.org/pixivfe/pixivfe/v3/core/untrusted"
)

// StreetParams holds the parameters for a street API request.
type StreetParams struct {
	Page             int
	ContentIndexPrev int
	K                string

	// The following fields are comma-separated lists of work IDs
	// that the user has already seen, used to avoid showing duplicates in the UI.
	Vhi string // Likely "viewed home illust".
	Vhm string // Likely "viewed home manga".
	Vhn string // Likely "viewed home novel".
}

// StreetNextParams holds the data needed by the frontend to make the next GET request for infinite scrolling.
type StreetNextParams struct {
	Page             int    `json:"page"`
	ContentIndexPrev int    `json:"content_index_prev"`
	K                string `json:"k"`
	Vhi              string `json:"vhi"`
	Vhm              string `json:"vhm"`
	Vhn              string `json:"vhn"`
}

// StreetData is the final, processed data structure returned to the frontend.
//
// It contains the page title and the parsed body of the API response.
type StreetData struct {
	streetResponse

	Title string
	// NextParams contains the parameters for the next page,
	// ready to be used for the next API request.
	// It is nil if there is no next page.
	NextParams *StreetNextParams
}

// streetResponse models the `body` field of the JSON response from the street API.
// It contains the primary feed content and pagination information.
type streetResponse struct {
	// RawContents holds the raw JSON for each item in the feed.
	// Because the items can be of different kinds (illust, manga, etc.),
	// we unmarshal it into specific types in the GetStreet function.
	RawContents []json.RawMessage `json:"contents"`

	// Contents holds the fully-parsed, typed content items after processing.
	Contents []any

	IsNewUserToStreet bool `json:"isNewUserToStreet"`
	ZoneConfig        any  `json:"-"` // NOTE: Data for ads, intentionally not modeled.
	NextParams        struct {
		Page             int `json:"page"`
		ContentIndexPrev int `json:"content_index_prev"`
	} `json:"nextParams"`
	States []any `json:"states"`
}

// contentItem is a helper struct to determine the "kind" of a feed item
// before unmarshalling it into its full, specific struct.
type contentItem struct {
	Kind string `json:"kind"`
}

// access holds telemetry and metadata about why a specific content item was
// recommended to the user.
//
// When the frontend determines that a user has "engaged" with a feed item
// (e.g., by dwelling on it for a few seconds), it sends this entire object
// back to the `/ajax/street/access` endpoint.
type access struct {
	// Key is a unique hash identifying a specific recommendation instance.
	Key string `json:"key"`

	// Typ is the type of the content, e.g., "illust", "manga", "novel".
	Typ string `json:"typ"`

	// CID is the Content ID of the work.
	CID int `json:"cid"`

	// I is the item's zero-based index in the final, blended feed that was served to the user.
	I int `json:"i"`

	// T is a Unix timestamp.
	// Likely represents when the feed was generated or the recommendation was made.
	T int `json:"t"`

	// Ism has an unconfirmed meaning.
	// Potentially stands for "is manga".
	Ism int `json:"ism"`

	// Aui is the Author's User ID.
	Aui int `json:"aui"`

	// Tgs is the list of all tags associated with the work.
	Tgs []string `json:"tgs"`

	// Rms holds metadata from the Recommendation System itself.
	// It contains the "reasons why" an item was selected.
	Rms struct {
		// Scr is the recommendation Score assigned to this item by the model.
		// A higher score indicates a higher confidence that the user will be interested.
		Scr float64 `json:"scr"`

		// Mtd is the recommendation Method (or a list of methods) used.
		// The names are often descriptive, e.g., "illust_for_user_mf_vh_bookmark"
		// (suggesting a model based on Most Frequent View History & Bookmarks) or
		// "history_clustering_bqalgc" (clustering based on view history).
		Mtd []string `json:"mtd"`

		// Pos is the item's Position (rank) within the candidate set generated by
		// a specific algorithm (`Mtd`), *before* it was blended into the final user-facing feed.
		Pos int `json:"pos"`

		// Sii is a list of "Similar Illust IDs".
		// These are likely the IDs of works the user previously interacted with
		// that caused the algorithm to recommend the current item.
		Sii []string `json:"sii"`

		// Sni is a list of "Similar Novel IDs", serving the same purpose as Sii but for novels.
		Sni []json.Number `json:"sni"`

		// Rli is likely a "Recommendation Log ID" or "Request Log ID".
		// It is a unique identifier for the entire batch of recommendations generated in a single request.
		Rli string `json:"rli"`
	} `json:"rms"`

	// C is a Comment ID.
	// If present, it matches the ID of a "pickup" comment displayed with the artwork.
	C int `json:"c,omitempty"`

	// Tt is the "Topic Tag" for which this item is being recommended.
	// It represents the system's specific guess about the user's current interest
	// (e.g., "GenshinImpact"). It is more specific than the general `Mtd`.
	Tt string `json:"tt,omitempty"`
}

// pickupComment holds a featured comment on a work.
type pickupComment struct {
	Type            string `json:"type"`
	UserID          string `json:"userId"`
	UserName        string `json:"userName"`
	ProfileImageURL string `json:"profileImageUrl"`
	ProfileImageAcs int    `json:"profileImageAcs"`
	ProfileImageMrs int    `json:"profileImageMrs"`
	CommentID       int    `json:"commentId"`
	Comment         string `json:"comment"`
	CommentCount    int    `json:"commentCount"`
}

// IllustMangaThumbnail holds the core metadata and assets for an illustration or manga.
//
// Typically the first and only element in the Thumbnails array of an IllustMangaContent.
type IllustMangaThumbnail struct {
	Type         string `json:"type"` // "illust" or "manga"
	ID           string `json:"id"`
	Title        string `json:"title"`
	EpisodeCount int    `json:"episodeCount,omitempty"`
	PageCount    int    `json:"pageCount"`
	Pages        []struct {
		Width  int `json:"width"`
		Height int `json:"height"`
		Urls   struct {
			Standard string `json:"1200x1200_standard"`
			Medium   string `json:"540x540"`
			Small    string `json:"360x360"`
		} `json:"urls"`
	} `json:"pages"`
	BookStyle       int `json:"bookStyle,omitempty"` // 0 for right-to-left, 1 for left-to-right.
	CustomThumbnail struct {
		CropX float64 `json:"cropX"`
		CropY float64 `json:"cropY"`
	} `json:"customThumbnail"` // Defines a specific crop for a thumbnail image.

	ShowTags bool       `json:"showTags"`
	RawTags  StreetTags `json:"tags"`
	Tags     Tags

	UserID            string `json:"userId"`
	UserName          string `json:"userName"`
	ProfileImageURL   string `json:"profileImageUrl"`
	RawCreateDate     string `json:"createDate"`
	RawUpdateDate     string `json:"updateDate"`
	CreateDate        time.Time
	UpdateDate        time.Time
	UpdateDuration    time.Duration // Time difference between UpdateDate and CreateDate
	CommentOffSetting int           `json:"commentOffSetting"`
	AIType            AIType        `json:"aiType"`
	Bookmarkable      bool          `json:"bookmarkable"`

	SeriesID    string `json:"seriesId,omitempty"`
	SeriesTitle string `json:"seriesTitle,omitempty"`
}

// IllustMangaContent represents a single illustration or manga post in the feed.
//
// The core content is nested inside the Thumbnails array.
type IllustMangaContent struct {
	Kind       string                 `json:"kind"`
	Thumbnails []IllustMangaThumbnail `json:"thumbnails"`

	// Pickup holds a featured comment on the work.
	Pickup *pickupComment `json:"pickup,omitempty"`

	Access access `json:"access"`
}

// TagsCarouselContent is a UI component for showcasing trending tags with example illustrations.
type TagsCarouselContent struct {
	Kind string `json:"kind"`

	// Thumbnails for a carousel contains a list of illustration thumbnail objects
	// to display inside the horizontally scrolling component.
	Thumbnails []IllustMangaThumbnail `json:"thumbnails"`

	TrendTags []struct {
		Name           string `json:"name"`
		TranslatedName any    `json:"translatedName"`
		TaggedCount    int    `json:"taggedCount"`
		URL            string `json:"url"`
	} `json:"trendTags"`
}

// NovelThumbnail represents the data within a novel's thumbnail object.
//
// Unlike illustrations, this object also contains the core text content.
// Typically the first and only element in the Thumbnails array of a NovelContent.
type NovelThumbnail struct {
	Type        string `json:"type"`
	ID          string `json:"id"`
	Title       string `json:"title"`
	URL         string `json:"url"`
	Description string `json:"description"`
	Text        string `json:"text"`

	EpisodeCount  int  `json:"episodeCount,omitempty"`
	WordCount     int  `json:"wordCount"`
	TextCount     int  `json:"textCount"`
	ReadingTime   int  `json:"readingTime"`
	UseWordCount  bool `json:"useWordCount"`
	BookmarkCount int  `json:"bookmarkCount"`
	IsOriginal    bool `json:"isOriginal"`

	ShowTags bool       `json:"showTags"`
	RawTags  StreetTags `json:"tags"`
	Tags     Tags

	UserID            string `json:"userId"`
	UserName          string `json:"userName"`
	ProfileImageURL   string `json:"profileImageUrl"`
	RawCreateDate     string `json:"createDate"`
	RawUpdateDate     string `json:"updateDate"`
	CreateDate        time.Time
	UpdateDate        time.Time
	UpdateDuration    time.Duration // Time difference between UpdateDate and CreateDate
	CommentOffSetting int           `json:"commentOffSetting"`
	AiType            int           `json:"aiType"`
	Bookmarkable      bool          `json:"bookmarkable"`

	SeriesID    string `json:"seriesId,omitempty"`
	SeriesTitle string `json:"seriesTitle,omitempty"`
}

// NovelContent represents a text-based story in the feed.
//
// The core content is nested inside the Thumbnails array.
type NovelContent struct {
	Kind       string           `json:"kind"`
	Thumbnails []NovelThumbnail `json:"thumbnails"`

	Pickup *pickupComment `json:"pickup,omitempty"`

	Access access `json:"access"`
}

type pixivisionThumbnail struct {
	SubCategory      string `json:"subCategory"`
	SubCategoryLabel string `json:"subCategoryLabel"`
	Title            string `json:"title"`
	URL              string `json:"url"`
	ImageURL         string `json:"imageUrl"`
}

type PixivisionContent struct {
	Kind       string                `json:"kind"`
	Thumbnails []pixivisionThumbnail `json:"thumbnails"`
	SeeAllURL  string                `json:"seeAllUrl"`
}

// SeparatorContent is a simple UI element used to create a visual break in the feed.
type SeparatorContent struct {
	Kind string `json:"kind"`
	ID   string `json:"id"`
}

// streetRequestNextParams represents the "params" field for subsequent page loads.
type streetRequestNextParams struct {
	Page             int `json:"page"`
	ContentIndexPrev int `json:"content_index_prev"`
}

// streetRequestPayload is the JSON payload sent to the street endpoint.
//
// Pointers distinguish between an empty value and a value
// that should be omitted (e.g. `params`) or sent as `null` (e.g. `k`).
type streetRequestPayload struct {
	Params *streetRequestNextParams `json:"params,omitempty"`
	K      *string                  `json:"k"`
	Vhi    *string                  `json:"vhi"`
	Vhm    *string                  `json:"vhm"`
	Vhn    *string                  `json:"vhn"`
}

// GetStreet fetches and processes the content feed from pixiv's "street" endpoint.
//
// This feed is a mixed-content list.
//
// TODO: This data should be integrated into the index page rather than being a separate route,
// similar to the official frontend.
func GetStreet(r *http.Request, params StreetParams) (*StreetData, error) {
	// Build the request payload from the provided params using a flat, guard-first style.
	payload := streetRequestPayload{}
	if params.Vhi != "" {
		payload.Vhi = &params.Vhi
	}

	if params.Vhm != "" {
		payload.Vhm = &params.Vhm
	}

	if params.Vhn != "" {
		payload.Vhn = &params.Vhn
	}
	// Pagination params are only sent on subsequent requests.
	if params.Page > 0 {
		payload.Params = &streetRequestNextParams{
			Page:             params.Page,
			ContentIndexPrev: params.ContentIndexPrev,
		}
		if params.K != "" {
			payload.K = &params.K
		}
	}

	jsonPayload, err := json.Marshal(payload)
	if err != nil {
		return nil, err
	}

	var body streetResponse

	resp, err := requests.PostJSONBody(
		r.Context(),
		GetStreetURL(),
		string(jsonPayload),
		map[string]string{"PHPSESSID": untrusted.GetUserToken(r)},
		untrusted.GetCookie(r, cookie.CSRFCookie),
		"application/json; charset=utf-8",
		r.Header,
	)
	if err != nil {
		return nil, err
	}

	if err := json.Unmarshal(RewriteEscapedImageURLs(r, resp), &body); err != nil {
		return nil, err
	}

	// Initialize the slice for processed content.
	body.Contents = make([]any, 0, len(body.RawContents))

	// Iterate through the raw JSON messages and unmarshal each into its specific type.
	for _, rawContent := range body.RawContents {
		var itemKind contentItem
		if err := json.Unmarshal(rawContent, &itemKind); err != nil {
			// Skip this item if we can't determine its kind.
			continue
		}

		// TODO: Implement lead and possibly ranking.
		switch itemKind.Kind {
		case "illust", "manga":
			var art IllustMangaContent
			if err := json.Unmarshal(rawContent, &art); err != nil {
				return nil, err
			}

			// Process pickup comment if present.
			if art.Pickup != nil {
				art.Pickup.Comment = parseEmojis(art.Pickup.Comment)
			}

			// No thumbnails, append as-is.
			if len(art.Thumbnails) == 0 {
				body.Contents = append(body.Contents, art)

				continue
			}

			thumb := &art.Thumbnails[0]

			thumb.Tags = thumb.RawTags.ToTags()

			// Date parsing.
			if thumb.RawCreateDate != "" {
				pt, err := time.Parse(PixivTimeLayout, thumb.RawCreateDate)
				if err != nil {
					return nil, fmt.Errorf("parsing create date for illust %s: %w", thumb.ID, err)
				}

				thumb.CreateDate = pt
			}

			if thumb.RawUpdateDate != "" {
				pt, err := time.Parse(PixivTimeLayout, thumb.RawUpdateDate)
				if err != nil {
					return nil, fmt.Errorf("parsing update date for illust %s: %w", thumb.ID, err)
				}

				thumb.UpdateDate = pt
			}

			if !thumb.CreateDate.IsZero() && !thumb.UpdateDate.IsZero() {
				thumb.UpdateDuration = thumb.UpdateDate.Sub(thumb.CreateDate)
			}

			body.Contents = append(body.Contents, art)

		case "tags_carousel":
			var carousel TagsCarouselContent
			if err := json.Unmarshal(rawContent, &carousel); err != nil {
				return nil, err
			}

			// Overwrite the TrendTags URLs to point to our search page.
			for i := range carousel.TrendTags {
				tag := &carousel.TrendTags[i]

				tag.URL = "/search?name=" + tag.Name
			}

			for i := range carousel.Thumbnails {
				thumb := &carousel.Thumbnails[i]

				thumb.Tags = thumb.RawTags.ToTags()

				if thumb.RawCreateDate != "" {
					if pt, err := time.Parse(PixivTimeLayout, thumb.RawCreateDate); err == nil {
						thumb.CreateDate = pt
					}
				}

				if thumb.RawUpdateDate != "" {
					if pt, err := time.Parse(PixivTimeLayout, thumb.RawUpdateDate); err == nil {
						thumb.UpdateDate = pt
					}
				}

				if !thumb.CreateDate.IsZero() && !thumb.UpdateDate.IsZero() {
					thumb.UpdateDuration = thumb.UpdateDate.Sub(thumb.CreateDate)
				}
			}

			body.Contents = append(body.Contents, carousel)

		case "novel":
			var novel NovelContent
			if err := json.Unmarshal(rawContent, &novel); err != nil {
				return nil, err
			}

			// No thumbnails, append as-is.
			if len(novel.Thumbnails) == 0 {
				body.Contents = append(body.Contents, novel)

				continue
			}

			thumb := &novel.Thumbnails[0]

			thumb.Tags = thumb.RawTags.ToTags()

			if thumb.RawCreateDate != "" {
				pt, err := time.Parse(PixivTimeLayout, thumb.RawCreateDate)
				if err != nil {
					return nil, fmt.Errorf("parsing create date for novel %s: %w", thumb.ID, err)
				}

				thumb.CreateDate = pt
			}

			if thumb.RawUpdateDate != "" {
				pt, err := time.Parse(PixivTimeLayout, thumb.RawUpdateDate)
				if err != nil {
					return nil, fmt.Errorf("parsing update date for novel %s: %w", thumb.ID, err)
				}

				thumb.UpdateDate = pt
			}

			if !thumb.CreateDate.IsZero() && !thumb.UpdateDate.IsZero() {
				thumb.UpdateDuration = thumb.UpdateDate.Sub(thumb.CreateDate)
			}

			body.Contents = append(body.Contents, novel)

		case "pixivision":
			var pixivision PixivisionContent
			if err := json.Unmarshal(rawContent, &pixivision); err != nil {
				return nil, err
			}

			body.Contents = append(body.Contents, pixivision)

		case "separator":
			var separator SeparatorContent
			if err := json.Unmarshal(rawContent, &separator); err != nil {
				return nil, err
			}

			body.Contents = append(body.Contents, separator)

		default:
			// Unknown kinds are ignored.
			continue
		}
	}

	return &StreetData{
		Title:          "Street",
		streetResponse: body,
		NextParams:     buildStreetNextParams(params, &body),
	}, nil
}

// buildStreetNextParams constructs the parameters for the next page of the street feed.
//
// It aggregates seen content IDs from the current request parameters and the new
// response content to prevent duplicates on subsequent page loads. It returns nil
// if there is no next page.
func buildStreetNextParams(params StreetParams, resp *streetResponse) *StreetNextParams {
	// If there are no more pages, there are no next params.
	if resp.NextParams.Page <= 0 {
		return nil
	}

	// The vhi, vhm, and vhn parameters are comma-separated lists of content IDs
	// that the user has already seen. We must append the IDs from the current
	// response to these lists for the next request.
	var seenIllusts, seenManga, seenNovels []string
	if params.Vhi != "" {
		seenIllusts = strings.Split(params.Vhi, ",")
	}

	if params.Vhm != "" {
		seenManga = strings.Split(params.Vhm, ",")
	}

	if params.Vhn != "" {
		seenNovels = strings.Split(params.Vhn, ",")
	}

	// Collect IDs from the newly fetched content.
	for _, content := range resp.Contents {
		switch item := content.(type) {
		case IllustMangaContent:
			if len(item.Thumbnails) > 0 {
				thumb := item.Thumbnails[0]
				switch thumb.Type {
				case "illust":
					seenIllusts = append(seenIllusts, thumb.ID)
				case "manga":
					seenManga = append(seenManga, thumb.ID)
				}
			}
		case NovelContent:
			if len(item.Thumbnails) > 0 {
				seenNovels = append(seenNovels, item.Thumbnails[0].ID)
			}
		}
	}

	return &StreetNextParams{
		Page:             resp.NextParams.Page,
		ContentIndexPrev: resp.NextParams.ContentIndexPrev,
		K:                "separator", // TODO: Known values are "separator" and "carousel".
		Vhi:              strings.Join(seenIllusts, ","),
		Vhm:              strings.Join(seenManga, ","),
		Vhn:              strings.Join(seenNovels, ","),
	}
}

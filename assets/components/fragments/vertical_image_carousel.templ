package fragments

import (
	"codeberg.org/pixivfe/pixivfe/v3/core"
	"codeberg.org/pixivfe/pixivfe/v3/core/cookie"
	"codeberg.org/pixivfe/pixivfe/v3/server/template"
	"codeberg.org/pixivfe/pixivfe/v3/server/template/commondata"
	"fmt"
)

// Badge represents a small, colored indicator for an item.
type Badge struct {
	Text  string
	Color string // e.g., "warning", "danger"
}

// verticalImageCarouselItem represents a single card in the carousel.
type verticalImageCarouselItem struct {
	Title             string
	SubtitleComponent templ.Component // A pre-rendered component for complex subtitles.
	Href              templ.SafeURL
	ImageSrc          string
	ImageAlt          string
	ShowPlayIcon      bool
	ShowCensorOverlay bool
	Badges            []Badge
	ActionComponent   templ.Component // A pre-rendered component for actions like bookmarking.
	LinkTarget        string
}

// VerticalImageCarouselProps contains the properties for the VerticalImageCarousel component.
type VerticalImageCarouselProps struct {
	// Items is the slice of prepared data to be rendered by the carousel.
	Items []verticalImageCarouselItem

	// EndCard is an optional component to be displayed at the end of the carousel,
	// typically used for a "View All" or "Load More" link.
	EndCard templ.Component
}

// ArtworkItemToCarouselItems is a view model adapter that converts []core.ArtworkItem
// into a slice of verticalImageCarouselItem.
func ArtworkItemToCarouselItems(cd commondata.PageCommonData, works []core.ArtworkItem) []verticalImageCarouselItem {
	var items []verticalImageCarouselItem

	visibilityR18 := cd.CookieList[cookie.VisibilityArtR18Cookie]
	visibilityR18G := cd.CookieList[cookie.VisibilityArtR18GCookie]
	visibilityAI := cd.CookieList[cookie.VisibilityArtAICookie]
	linkTarget := cd.CookieList[cookie.ThumbnailToNewTabCookie]

	for _, work := range works {
		if work.ShouldHide(cd.CookieList) {
			continue
		}

		showCensorOverlay := false
		loadReplacementImage := false

		if (work.XRestrict == 1 && visibilityR18 == "censor") || (work.XRestrict == 2 && visibilityR18G == "censor") {
			showCensorOverlay = true
			loadReplacementImage = true
		} else if work.AIType == 2 && visibilityAI == "censor" {
			showCensorOverlay = true
		}

		var imgSrc string
		if loadReplacementImage {
			imgSrc = "/img/nsfw.png"
		} else {
			imgSrc = work.Thumbnails.MasterWebp_1200
		}

		var badges []Badge
		if work.AIType == 2 {
			badges = append(badges, Badge{Text: "AI-generated", Color: "warning"})
		}
		if work.XRestrict == 1 {
			badges = append(badges, Badge{Text: "R-18", Color: "danger"})
		} else if work.XRestrict == 2 {
			badges = append(badges, Badge{Text: "R-18G", Color: "danger"})
		}

		var actionComponent templ.Component
		if cd.LoggedIn {
			if work.BookmarkData != nil {
				actionComponent = QuickDeleteBookmark(
					DeleteBookmarkData{ID: work.ID, BookmarkData: work.BookmarkData},
				)
			} else {
				actionComponent = QuickAddBookmark(
					AddBookmarkData{ID: work.ID},
				)
			}
		}

		items = append(items, verticalImageCarouselItem{
			Title:             work.Title,
			SubtitleComponent: artworkCarouselSubtitle(work),
			Href:              templ.URL("/artworks/" + work.ID),
			ImageSrc:          imgSrc,
			ImageAlt:          "Thumbnail for " + work.Title,
			ShowPlayIcon:      work.IllustType == int(core.Ugoira),
			ShowCensorOverlay: showCensorOverlay,
			Badges:            badges,
			ActionComponent:   actionComponent,
			LinkTarget:        linkTarget,
		})
	}
	return items
}

// StreetTagsCarouselToCarouselItems is a view model adapter that converts core.TagsCarouselContent
// into a slice of verticalImageCarouselItem for use in the VerticalImageCarousel component.
// Each item in the carousel represents a trending tag, using an associated artwork as a cover.
func StreetTagsCarouselToCarouselItems(cd commondata.PageCommonData, carousel core.TagsCarouselContent) []verticalImageCarouselItem {
	var items []verticalImageCarouselItem

	visibilityAI := cd.CookieList[cookie.VisibilityArtAICookie]
	linkTarget := cd.CookieList[cookie.ThumbnailToNewTabCookie]

	// The carousel items are the TrendTags. The Thumbnails provide the cover images.
	// We assume a 1:1 mapping between TrendTags and Thumbnails by index.
	for i, tag := range carousel.TrendTags {
		// Ensure there is a corresponding thumbnail to use as a cover.
		if i >= len(carousel.Thumbnails) {
			continue
		}
		work := carousel.Thumbnails[i]

		// Street content is never R-18, so no need for XRestrict checks.
		showCensorOverlay := false
		if work.AIType == 2 && visibilityAI == "censor" {
			showCensorOverlay = true
		}

		// A thumbnail must have at least one page to be displayed.
		if len(work.Pages) == 0 {
			continue
		}

		var badges []Badge
		if work.AIType == 2 {
			badges = append(badges, Badge{Text: "AI-generated", Color: "warning"})
		}

		items = append(items, verticalImageCarouselItem{
			Title:             tag.Name,
			SubtitleComponent: streetCarouselSubtitle(tag.TaggedCount),
			Href:              templ.URL(tag.URL),
			ImageSrc:          work.Pages[0].Urls.Standard,
			ImageAlt:          "Cover image for tag " + tag.Name,
			ShowPlayIcon:      false, // Street API does not serve ugoira in carousels.
			ShowCensorOverlay: showCensorOverlay,
			Badges:            badges,
			ActionComponent:   nil, // Tags cannot be bookmarked.
			LinkTarget:        linkTarget,
		})
	}
	return items
}

// streetCarouselSubtitle is a private component that renders the subtitle part of the
// carousel item for a tag from the Street API, showing the number of works.
templ streetCarouselSubtitle(taggedCount int) {
	<div class="flex items-center gap-1">
		<div class="material-symbols-rounded-20">label</div>
		<div>{ fmt.Sprintf("%s works", template.PrettyNumber(taggedCount)) }</div>
	</div>
}

// artworkCarouselSubtitle is a private component that renders the subtitle
// part of the carousel item, containing metadata like date and page count.
templ artworkCarouselSubtitle(item core.ArtworkItem) {
	{{ relativeTimeData := template.RelativeTime(item.CreateDate) }}
	// Creation date as relative time
	<div class="flex items-center gap-1">
		<div class="material-symbols-rounded-20">event</div>
		<div>
			<span>{ relativeTimeData.Value }</span>
			<span>{ relativeTimeData.Description }</span>
			if relativeTimeData.Time != "" {
				<span>{ relativeTimeData.Time }</span>
			}
		</div>
	</div>
	if item.Pages > 1 {
		<div class="flex items-center ps-2 border-s border-neutral-400 gap-1">
			<div class="material-symbols-rounded-20">image</div>
			if item.IllustType == int(core.Manga) {
				<div>{ fmt.Sprintf("%d pages", item.Pages) }</div>
			} else {
				<div>{ fmt.Sprintf("%d images", item.Pages) }</div>
			}
		</div>
	}
}

// VerticalImageCarousel renders a generic horizontal-scrolling carousel of vertical images.
templ VerticalImageCarousel(props VerticalImageCarouselProps) {
	<div class="grid grid-rows-1 grid-flow-col overflow-x-auto snap-x snap-mandatory gap-4 pb-4 -mb-4">
		for _, item := range props.Items {
			{{
				overlayBgClass := ""
				if item.ShowCensorOverlay {
					overlayBgClass = "bg-black/80 group-hover/image:bg-black/40"
				}
			}}
			// The whole container for a single item
			<div class="relative h-full w-72 sm:w-96 aspect-[1/1.414] rounded-lg overflow-hidden snap-start isolate">
				<a
					class="group/image absolute inset-0 is-artwork"
					target={ item.LinkTarget }
					href={ item.Href }
				>
					if item.ShowCensorOverlay {
						<div
							class={ templ.Classes(
								"flex flex-col items-center justify-center absolute size-full rounded inset-0 gap-2 z-2 transition",
								templ.Class(overlayBgClass),
							) }
						>
							<span
								class="material-symbols-rounded-48 group-hover/image:opacity-0 opacity-100 text-neutral-400 transition-all"
							>
								visibility_off
							</span>
						</div>
					}
					// Thumbnail
					<img
						src={ item.ImageSrc }
						alt={ item.ImageAlt }
						loading="lazy"
						class="size-full group-hover/image:scale-[1.025] transition duration-300 object-cover object-top"
					/>
					// Play button overlay for ugoira
					if item.ShowPlayIcon {
						<div class="flex absolute inset-2/4 -translate-x-1/2 -translate-y-1/2 justify-center items-center bg-black/75 group-hover/image:bg-black/50 group-hover/image:text-neutral-100/80 transition rounded-full p-7 z-1 isolate">
							<span class="material-symbols-rounded-fill-48">
								play_arrow
							</span>
						</div>
					}
					// Main absolute wrapper to stack children vertically
					<div class="absolute inset-0 flex flex-col size-full">
						// Header content
						<div class="w-full bg-gradient-to-b from-black/80 to-black/60 px-6 pt-5 pb-10 rounded-t-lg">
							// Title
							<div class="flex items-center gap-4">
								<div class="text-xl tracking-tight text-white font-bold text-balance">
									{ item.Title }
								</div>
							</div>
							// Subtitle (creation date and pages/images)
							if item.SubtitleComponent != nil {
								<div class="flex items-center flex-wrap text-sm text-neutral-300 gap-2 mt-2">
									@item.SubtitleComponent
								</div>
							}
							// Badge overlay
							if len(item.Badges) > 0 {
								<div class="flex items-center gap-2 mt-4">
									for _, badge := range item.Badges {
										if badge.Color == "warning" {
											<div class="badge-warning">{ badge.Text }</div>
										} else if badge.Color == "danger" {
											<div class="badge-danger">{ badge.Text }</div>
										}
									}
								</div>
							}
						</div>
						// A separate element for the gradient fade-out effect
						<div class="size-full bg-gradient-to-b from-black/60 to-transparent to-40%"></div>
					</div>
				</a>
				// Quick action buttons, positioned absolutely relative to the container
				if item.ActionComponent != nil {
					<div class="absolute right-2 bottom-2 z-10">
						@item.ActionComponent
					</div>
				}
			</div>
		}
		if props.EndCard != nil {
			@props.EndCard
		}
	</div>
}

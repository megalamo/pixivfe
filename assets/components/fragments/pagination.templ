package fragments

import (
	"fmt"
	"net/url"
	"strconv"
	"strings"
)

// PaginationProps contains the raw data needed to build the pagination component.
type PaginationProps struct {
	BaseURL     string // The base part of the pagination URL, e.g., "/search?name=test&page="
	EndingURL   string // The ending part of the URL, e.g., "&mode=r18"
	CurrentPage int    // The current active page number.
	MaxPage     int    // The total number of pages. -1 if unknown.
	// PageMargin  int    // Number of page links to show around the current page.
}

// pageInfo represents a single page link in the pagination control.
type pageInfo struct {
	Number int
	URL    string
}

// paginationViewModel holds the processed data ready for rendering.
type paginationViewModel struct {
	CurrentPage int
	MaxPage     int
	Pages       []pageInfo
	HasPrevious bool
	HasNext     bool
	PreviousURL string
	NextURL     string
	FirstURL    string
	LastURL     string
	HasMaxPage  bool
	LastPage    int
}

// Pagination renders a pagination component.
templ Pagination(props PaginationProps) {
	{{
		// Process the raw props into a view model for rendering.
		// All complex logic is handled here, keeping the template clean.
		vm := newPaginationViewModel(props)
	}}
	<nav aria-label="Pagination">
		<!-- Prefetch links -->
		if len(vm.Pages) > 0 {
			if vm.HasPrevious {
				<link rel="prefetch" href={ templ.URL(vm.PreviousURL) }/>
			}
			if len(vm.Pages) > 0 && vm.Pages[0].Number > 1 {
				<link rel="prefetch" href={ templ.URL(vm.FirstURL) }/>
			}
			if vm.HasMaxPage && vm.LastPage < vm.MaxPage {
				<link rel="prefetch" href={ templ.URL(vm.LastURL) }/>
			}
			if vm.HasNext {
				<link rel="prefetch" href={ templ.URL(vm.NextURL) }/>
			}
		}
		<div class="flex flex-col items-center content-center gap-6">
			if len(vm.Pages) > 0 {
				<!-- Page numbers -->
				<div class="flex flex-row items-center gap-2">
					<!-- Previous page button -->
					if vm.HasPrevious {
						<a href={ templ.URL(vm.PreviousURL) }>
							<div class="filled-button justify-center text-sm font-medium min-w-15 min-h-10 me-2">
								Prev
							</div>
						</a>
					} else {
						<button
							disabled
							class="outlined-button justify-center font-medium text-sm text-neutral-500 min-w-15 min-h-10 me-2"
							title="No previous page exists."
						>
							Prev
						</button>
					}
					<!-- First page and ellipsis (if needed) -->
					if len(vm.Pages) > 0 && vm.Pages[0].Number > 1 {
						<a href={ templ.URL(vm.FirstURL) }>
							<div class="tonal-button-neutral justify-center text-sm font-medium min-w-10 min-h-10">
								1
							</div>
						</a>
						if vm.Pages[0].Number > 2 {
							<div class="text-neutral-700 select-none">…</div>
						}
					}
					<!-- Page numbers -->
					for _, page := range vm.Pages {
						if page.Number == vm.CurrentPage {
							<button>
								<div class="bg-neutral-700 text-neutral-100 flex items-center justify-center text-sm font-bold rounded-full min-w-10 min-h-10">
									{ strconv.Itoa(page.Number) }
								</div>
							</button>
						} else {
							<a href={ templ.URL(page.URL) }>
								<div class="bg-neutral-800 text-neutral-200 flex items-center justify-center hover:text-neutral-900 hover:bg-neutral-300 active:scale-95 text-sm font-medium rounded-full min-w-10 min-h-10 transition">
									{ strconv.Itoa(page.Number) }
								</div>
							</a>
						}
					}
					<!-- Last page and ellipsis (if needed) -->
					if vm.HasMaxPage && vm.LastPage < vm.MaxPage {
						if vm.LastPage < vm.MaxPage-1 {
							<div class="text-neutral-700 select-none">…</div>
						}
						<a href={ templ.URL(vm.LastURL) }>
							<div class="tonal-button-neutral justify-center text-sm font-medium min-w-10 min-h-10">
								{ strconv.Itoa(vm.MaxPage) }
							</div>
						</a>
					}
					<!-- Next page button -->
					if vm.HasNext {
						<a href={ templ.URL(vm.NextURL) }>
							<div class="filled-button justify-center text-sm font-medium min-w-15 min-h-10 ms-2">
								Next
							</div>
						</a>
					} else {
						<button
							disabled
							class="outlined-button justify-center font-medium text-sm text-neutral-500 min-w-15 min-h-10 ms-2"
							title="No next page exists."
						>
							Next
						</button>
					}
				</div>
				<!-- Page selector -->
				<form action="" method="GET" class="flex items-center gap-3">
					{{
						urlObj, _ := url.Parse(vm.NextURL)
						rawQueries, _ := url.ParseQuery(urlObj.RawQuery)
					}}
					for k, v := range rawQueries {
						if k != "page" {
							<input type="hidden" name={ k } value={ strings.Join(v, "") }/>
						}
					}
					<input
						type="number"
						id="page"
						name="page"
						min="1"
						if vm.HasMaxPage {
							max={ strconv.Itoa(vm.MaxPage) }
						} else {
							max=""
						}
						placeholder={ strconv.Itoa(vm.CurrentPage) }
						required
						class="bg-neutral-800/25 border border-neutral-700 rounded text-neutral-200 placeholder:text-neutral-600 px-2 py-1"
					/>
					<button
						type="submit"
						class="flex items-center w-fit select-none rounded-full border-1 border-neutral-600 cursor-pointer hover:border-neutral-500 hover:bg-neutral-700 active:bg-neutral-800 active:shadow-inner active:scale-95 transition text-neutral-300 font-medium hover:text-neutral-50 px-4 py-1"
					>
						Go
					</button>
				</form>
			} else {
				<div class="flex flex-col items-center w-full border border-dashed border-neutral-500 text-center text-neutral-400 fill-neutral-400 rounded p-6 gap-2">
					<span class="material-symbols-rounded-20">indeterminate_question_box</span>
					<span class="text-sm">No items to display.</span>
				</div>
			}
		</div>
	</nav>
}

// newPaginationViewModel processes PaginationProps and prepares it for rendering.
// It contains the logic previously in the CreatePaginator function.
func newPaginationViewModel(props PaginationProps) paginationViewModel {
	// Input validation and normalization
	// If the current page is invalid or there are no pages, return an empty model.
	// This gracefully triggers the "No items" view in the template.
	if props.CurrentPage < 1 || (props.MaxPage != -1 && props.MaxPage < 1) {
		return paginationViewModel{}
	}

	pageMargin := 0

	hasMaxPage := props.MaxPage != -1

	// URL generation
	pageURL := func(page int) string {
		// This matches the simple string concatenation from the original CreatePaginator.
		return fmt.Sprintf(`%s%d%s`, props.BaseURL, page, props.EndingURL)
	}

	// Page range calculation
	start := props.CurrentPage - pageMargin
	if start < 1 {
		start = 1
	}

	end := props.CurrentPage + pageMargin
	if hasMaxPage && end > props.MaxPage {
		end = props.MaxPage
	}

	// Page list generation
	var pages []pageInfo
	if start <= end {
		// Pre-allocate slice capacity for performance.
		pages = make([]pageInfo, 0, end-start+1)
		for i := start; i <= end; i++ {
			pages = append(pages, pageInfo{Number: i, URL: pageURL(i)})
		}
	}

	// Determine last visible page number
	var lastPage int
	if len(pages) > 0 {
		lastPage = pages[len(pages)-1].Number
	} else {
		// Fallback for cases like max_page=0 where no page numbers are rendered.
		lastPage = props.CurrentPage
	}

	// Build and return the final view model
	vm := paginationViewModel{
		CurrentPage: props.CurrentPage,
		MaxPage:     props.MaxPage,
		Pages:       pages,
		HasPrevious: props.CurrentPage > 1,
		HasNext:     !hasMaxPage || props.CurrentPage < props.MaxPage,
		FirstURL:    pageURL(1),
		HasMaxPage:  hasMaxPage,
		LastPage:    lastPage,
	}

	if vm.HasPrevious {
		vm.PreviousURL = pageURL(props.CurrentPage - 1)
	}
	if vm.HasNext {
		vm.NextURL = pageURL(props.CurrentPage + 1)
	}
	if vm.HasMaxPage {
		vm.LastURL = pageURL(props.MaxPage)
	}

	return vm
}
